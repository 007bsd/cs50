
> Logical and && : x and y both are true
> Logical OR || : x is or y true

> ternianry operators:

int x = (expr) ? 5: 6

5 is true
6 is false

> Loops:

1) while (expr)
{
}

2)
do {
}
while(expr)


3) For loop


> const is use in the variable to make sure the value is not changed
const int N = 3;
This can be put on top of the program

> clang -o average_array average_array.c -lcs50

\0:  Null character at the string. It is always available at the end (check names.c file in week_2)

int main(int argc, string argv[])

argc : argument counter
argv : argument vectors

Functions:

return_type name (argument type)

int add_two_ints(int a, int b){
  int sum;
  sum = a + b;
  return sum;
}
> when Functions do not take any arguments called void type
> When functions do not return any arguments type called void return


Arrays:
> Arrays is a data structure which holds values for contineous memory location
> It holds the same data types
> Array can be access with the help of index numbers
> The index of array always starts with 0 and end of the index is end with n-1

type name[size]

double menu_prices[8]

> You do not need to explicitly declare the size of an Array
> Array variable can be assigned but not the array itself
> Array is usually pass by reference unlike variables in a function are pass by value


Week 3:
> Search type:
Linear search:
> From left to right
> Repeat from the starting of the array element

O(n): Worst case of finding an element
Omega(n): Best case of finding an element

Binary search:
> half of the search from left to right: Divide and search
> Sort the Array first
> Calculate the mid point and find the element from the sorted Array
> Keep repeating the process until you find the array

O(log n): Worst case of finding an element
Omega(1): Best case of finding an element

Selection Search:
> Select the smallest number from the unsorted array
> Swap the selected element with the first element of the unsorted part and keep repeating

Insertion Sort:
> Call the first element as sorted
> shift the element by inserting it
O(n2): Worst case
Omega(n): Best case

Bubble sort:
> Larger numbers compare with the immediate numbers to the side and end up at the end
> Swap counter. Look to the adjecent value and swap them and if they are out of order then add to the swap counter
> Repeat the swap counter to Zero until 0 after reset

O(n2) : Worst case
Omega(1): Best case scenarios


Recursive or Recursion:
> Call the sort inside another Sort

int fact(int n){
if (n == 1)
  return 1;
else
  return n * fact(n-1);
}

> Fibonaci series is multiple base cases
> multiple Recursion cases also called as collatz cases

collatz cases:
No of steps to get back to 1
> If n = 1 , stop
> If n is even, then repeat the process by n/2
> If n is odd, then repeat the process by 3n+1

int collatz(int n)
{
if (n ==1)
{
return 0;
}
else if(n %2 ==0)
{
return 1 + collatz(n/2);
}
else
{
return 1+ collatz(3*n+1);
}


Merge Sort:
> Merge sort is better for other search
> Sort the left half and sort the right half then merge the two Arrays

O(log n)
Omega(log n)

Algorithm:

Big O notation:
O(n), O(n) and O(log n)

O(n2): Bubble sort, selection sort
O(n): Binaray search
O(log n ): Linear search


Omega: Opposite of Binary search
Omega(n) : Selection sort, Bubble Sort
Omega(1): Linear search
Omega(log n): Binaray search


>typdef: to define a structure

typedef struct {
string details
}person;

person above is the name of the structure

#################Week 4

Hexadecimal: 0 1 2 3 4 5 6 7 8 9 A B C D E F
Decimal: 0 1 2 3 4 5 6 7 8 9

8 binray digit: 8 bits : 2*0 -- 2*7 : 1 2 4 8 16 32 64 128

FF in Decimal: 255 in decinal: 1 1 1 1 1 1 1 1 in binrary

int is 4 bytes

Address:
& : to get out the adress of the variable
%p: To print out that address 
* : Go to the address. It undo the operation

int *p : It is a pointer of the data type integer. It holds the address of the variable

int n = 50;
int *p = &n;


typedef char* string;

so char* 

> string can not be compare with the itself as they hold different address like integer

malloc: allocating new memory for string

char *t = malloc(strlen(s)+1)

The above is a data type of stdlib.h

free: free is a function to deallocate the same memory used in the memory

valgrind: It is a tool indentify the memory used 

help50 valigrind ./copy

swap

void swap (int a , int b){

int tmp =a;
a = b;
b = tmp;
}





