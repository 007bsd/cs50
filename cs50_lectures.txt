
> Logical and && : x and y both are true
> Logical OR || : x is or y true

> ternianry operators:

int x = (expr) ? 5: 6

5 is true
6 is false

> Loops:

1) while (expr)
{
}

2)
do {
}
while(expr)


3) For loop


> const is use in the variable to make sure the value is not changed
const int N = 3;
This can be put on top of the program

> clang -o average_array average_array.c -lcs50

\0:  Null character at the string. It is always available at the end (check names.c file in week_2)

int main(int argc, string argv[])

argc : argument counter
argv : argument vectors

Functions:

return_type name (argument type)

int add_two_ints(int a, int b){
  int sum;
  sum = a + b;
  return sum;
}
> when Functions do not take any arguments called void type
> When functions do not return any arguments type called void return


Arrays:
> Arrays is a data structure which holds values for contineous memory location
> It holds the same data types
> Array can be access with the help of index numbers
> The index of array always starts with 0 and end of the index is end with n-1

type name[size]

double menu_prices[8]

> You do not need to explicitly declare the size of an Array
> Array variable can be assigned but not the array itself
> Array is usually pass by reference unlike variables in a function are pass by value


Week 3:
> Search type:
Linear search:
> From left to right
> Repeat from the starting of the array element

O(n): Worst case of finding an element
Omega(n): Best case of finding an element

Binary search:
> half of the search from left to right: Divide and search
> Sort the Array first
> Calculate the mid point and find the element from the sorted Array
> Keep repeating the process until you find the array

O(log n): Worst case of finding an element
Omega(1): Best case of finding an element

Selection Search:
> Select the smallest number from the unsorted array
> Swap the selected element with the first element of the unsorted part and keep repeating

Insertion Sort:
> Call the first element as sorted
> shift the element by inserting it
O(n2): Worst case
Omega(n): Best case

Bubble sort:
> Larger numbers compare with the immediate numbers to the side and end up at the end
> Swap counter. Look to the adjecent value and swap them and if they are out of order then add to the swap counter
> Repeat the swap counter to Zero until 0 after reset

O(n2) : Worst case
Omega(1): Best case scenarios


Recursive or Recursion:
> Call the sort inside another Sort

int fact(int n){
if (n == 1)
  return 1;
else
  return n * fact(n-1);
}

> Fibonaci series is multiple base cases
> multiple Recursion cases also called as collatz cases

collatz cases:
No of steps to get back to 1
> If n = 1 , stop
> If n is even, then repeat the process by n/2
> If n is odd, then repeat the process by 3n+1

int collatz(int n)
{
if (n ==1)
{
return 0;
}
else if(n %2 ==0)
{
return 1 + collatz(n/2);
}
else
{
return 1+ collatz(3*n+1);
}


Merge Sort:
> Merge sort is better for other search
> Sort the left half and sort the right half then merge the two Arrays

O(log n)
Omega(log n)

Algorithm:

Big O notation:
O(n), O(n) and O(log n)

O(n2): Bubble sort, selection sort
O(n): Binaray search
O(log n ): Linear search


Omega: Opposite of Binary search
Omega(n) : Selection sort, Bubble Sort
Omega(1): Linear search
Omega(log n): Binaray search


>typdef: to define a structure

typedef struct {
string details
}person;

person above is the name of the structure

#################Week 4

Hexadecimal: 0 1 2 3 4 5 6 7 8 9 A B C D E F
Decimal: 0 1 2 3 4 5 6 7 8 9

8 binray digit: 8 bits : 2*0 -- 2*7 : 1 2 4 8 16 32 64 128

FF in Decimal: 255 in decinal: 1 1 1 1 1 1 1 1 in binrary

int is 4 bytes

Address:
& : to get out the adress of the variable
%p: To print out that address
* : Go to the address. It undo the operation

int *p : It is a pointer of the data type integer. It holds the address of the variable

int n = 50;
int *p = &n;


typedef char* string;

so char*

> string can not be compare with the itself as they hold different address like integer

malloc: allocating new memory for string

char *t = malloc(strlen(s)+1)

The above is a data type of stdlib.h

free: free is a function to deallocate the same memory used in the memory

valgrind: It is a tool indentify the memory used

help50 valigrind ./copy

swap

void swap (int a , int b){

int tmp =a;
a = b;
b = tmp;
}


#############################
Hexadecimal:
1111 : F
0x0 : Hexadecimal
0: Decimal

1 16 256

Pointers:

data type: size in bytes
int: 4
char: 1
float: 4
double: 8
long long: 8

Pointers are nothing more than an address. This is where the variable lives
It is value in the memory address. type describes the data located at that memory address

always set the value as NULL.

* : Deference operator used in Pointers

int pc = 5;
int *pt = &pc;

Deferencing a variable is called with NULL pointers is result in Segmentation fault

string : char *

Dynamic memory Allocation:
> Using pointers, we can dynamically allocated memory
> The memory leaves in the HEAP
malloc()

int x; // stack memory
int *px = malloc(sizeof(int))  // dynamically allocated memory

int x - GetInt(); // stack memory
float stack_array[x]; // array of floats in the stack

float *heap_array = malloc(x * sizeof(float)); // array of floats on the heap

// dynamically allocate the memory
char *word = malloc(50 * (sizeof(char)));

// free the memory

free(word);
Golden rule of the memory:
> Every block of memory should be subsequently free()
> Only memory that malloc() should be free()
> Do not free() a block of memory more than once

int m;
int * a;
int *b = malloc(sizeof(int));

a = &m;
a= b;
m =10;
*b = m +2; // b =12
free(b)

Call Stacks:

int fact(int n){
if (n ==1){
return 1;
}
else
{
return n * fact(n-1);
}
}

int main(void){
printf("%i\n", fact(5));
}

File Pointers:

FILE*

stdio.h > file headers for FILE
fopen(): opens a file and gives a file pointer to it

FILE * ptr = fopen(<file name>, <operation>);
FILE * ptr1 = fopen("file1.txt", "r");
FILE * ptr2 = fopen("file2.txt", "w");
FILE * ptr1 = fopen("file3.txt", "a");

fclose(): Closes the file
fclose(<file pointer>);
fclose(ptr1);

fgetc(): reads and returns the next character from the file pointed to
char ch = fgetc(<file pointer>);
char ch = fgetc(ptr1);

char ch;
while((ch = fgetc(ptr1)) != EOF)
  printf("%c", ch);
The above is same as that of cat.c in the linux os

fputc(): Writes a single character
fputc(<character>, <file pointer>);
 fputc("A", ptr2);
char ch;
while((ch = fgetc(ptr)) != EOF)
  fputc(ch, ptr2);
Above command is same as the linux cp command. cp.c

fread():
Read all the contents of the file.
fread(<buffer>, <size>, <qty>, <file pointer>);
int arr[10];
fread(arr, sizeof(int), 10, ptr);
double * arr2 = malloc(sizeof(double) * 80);
fread(arr2, sizeof(double), 80, ptr);
char c;
fread(&c, sizeof(char),1, ptr);

fwrite():
fwrite(<buffer>, <size>, <qty>, <filepointer>);
int arr[10];
fwrite(arr, sizeof(int), 10, ptr);
double * arr2 = malloc(sizeof(double) * 80);
fwrite(arr2, sizeof(double), 80, ptr);
char c;
fwrite(&c, sizeof(char),1, ptr);

fgets(): Reads the full string
fputs(): Writes the full string
fprintf(): writes the formatted string to a file
fseek(): allows to rewind and fast forward in a file
ftell(): Tells you at what byte position you are at
feof(): tells you whether you have read to the end of the file
ferror(): Indicates whether an error has occurred in the file
